/*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ˜“ WORST CASE BST EXAMPLE: Skewed Tree
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Example Input (insert in sorted order):
ğŸ”¢ Insert in order â†’ [1, 2, 3, 4, 5]

ğŸ¯ This creates a tree where each node only has a right child.

ğŸ“‰ Tree becomes RIGHT SKEWED like:

      1
       \
        2
         \
          3
           \
            4
             \
              5

ğŸ“Œ This is technically a valid BST, but it's completely unbalanced.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ PROBLEM:
- Searching, inserting, deleting now takes O(N) time.
- For node 5, we traverse all 4 nodes above it: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5

âœ… Balanced BST would have taken only O(log N) = O(log 5) â‰ˆ 3 steps max.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ HOW TO AVOID:
- Use **self-balancing trees** like AVL Tree or Red-Black Tree
- Or use **sorted array â†’ construct BST** using binary divide
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*/

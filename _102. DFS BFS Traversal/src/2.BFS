/*
==============================
ðŸ“˜ BFS (Breadth-First Search) / Level Order Traversal
==============================

Definition:
- Traverses the tree **level by level**, from **left to right**
- Starts from the root and visits nodes level-wise
- Uses a **Queue** to keep track of nodes to visit

ðŸ“˜ Use Cases:
- Shortest path in unweighted trees
- Serialization of trees
- Organizing tasks level by level (e.g., UI rendering, processes)

==============================
ðŸŒ³ Example Tree:
           ðŸ”µ1
          /   \
       ðŸ”µ2     ðŸ”µ3
      /   \      \
   ðŸ”µ4   ðŸ”µ5     ðŸ”µ6

==============================
ðŸ”¢ BFS Output (Level Order):
1 2 3 4 5 6

==============================
ðŸ§  Step-by-step:
1. Enqueue ðŸ”µ1
2. Dequeue 1 â†’ enqueue ðŸ”µ2 and ðŸ”µ3
3. Dequeue 2 â†’ enqueue ðŸ”µ4 and ðŸ”µ5
4. Dequeue 3 â†’ enqueue ðŸ”µ6
5. Dequeue 4, 5, 6 â†’ All are leaf nodes

Queue status at each step:
[1]
â†’ [2, 3]
â†’ [3, 4, 5]
â†’ [4, 5, 6]
â†’ [5, 6]
â†’ [6]
â†’ []

==============================
ðŸ“Œ BFS vs DFS:
- BFS uses a **Queue**, DFS uses **Recursion or Stack**
- BFS visits nodes level by level
- DFS goes deep before backtracking

==============================
ðŸ“Œ Time & Space Complexity:
- Time: O(n) (visits all nodes once)
- Space: O(n) in the worst case (queue holds all nodes at the widest level)

*/
